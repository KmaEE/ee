#import "@preview/cetz:0.2.2"
#show par: set block(spacing: 1.5em)
#set par(
  justify: true,
  leading: 0.75em
)
#set text(font: "IBM Plex Sans")


#heading(outlined: false)[To what extent can elliptic curves be used to establish a shared secret over an insecure channel?]

#pagebreak()

#outline(indent: 2em)

#pagebreak()

= Group Theory

== $ZZ_p^times$: The Multiplicative Group Over a Prime

Fermat's Little Theorem suggests the following to be true for any integer $a$ and prime $p$:

$
a^(p-1) equiv 1 " " (mod p)
$

Extracting a factor of $a$, we get

$
a dot a^(p-2) equiv 1 " " (mod p)
$

Thus, under multiplication modulo $p$, any integer $a$ multiplied by $a^(p-2)$ results in 1. As 1 is the multiplicative identity ($1 dot x = x$), $a^(p-2)$ is said to be $a$'s _multiplicative inverse_. Consider the numbers from $1$ to $p - 1$. Every number has a multiplicative inverse modulo $p$, and $1$ is the identity element as shown above. Further more, multiplication is associative ($a dot (b dot c) = (a dot b) dot c$) and each multiplication will always result in a number between $1$ to $p - 1$ since it is performed modulo $p$. These properties (existence of an identity element and inverses, associativity and closure of operations) form a group.

We will refer to the group as $ZZ_p^times$. The _order_ of a group refers to the number of elements in a group. For $ZZ_p^times$, the order is $p - 1$ since the elements are $1, 2, ..., p - 1$. Using notation, we write $|ZZ_p^times| = p - 1$.

The _order_ of a specific element $x$, refers to the smallest integer $k$ such that $x^k = 1$, where $1$ is the identity element.#footnote[On a first glance, the definitions of order for a group and its elements seem to be unrelated. While in fact, the order of an element is also the order of a _subgroup_ generated by that element. The meanings of "subgroup" and "generated" are outside the scope of this essay.] For example, the order of $17$ in $ZZ_1009^times$ is $1008$, because $1008$ is the smallest integer such that $17^1008 = 1$, whereas the order of $2$ in the same group is $504$, since $2^504 = 1$. Therefore, we have $|17| = 1008$ and $|2| = 504$.

== The Discrete Log Problem

Under a specific group $ZZ_1009^times$, we ask for an integer $n$ for which $17^n = 24$. In this case,

$
17^(456) equiv 24 " " (mod 1009)
$

Therefore $n = 456$ is the solution to this question. More generally, the discrete log problem (DLP) asks for a smallest exponent $n$ for a given group $g$ and its elements $a$ and $b$ such that

$
a^n = b
$

Given this problem, one might take the brute-force or complete search approach, repeatedly performing the group multiplication, calculating $a^2$, $a^3$, $a^4$ and so on to find $b$. In the example problem, it would take $455$ multiplications before finally arriving at the answer. Assuming the exponent $n$ is taken at random, this algorithm would take on average $1/2|a|$ operations. As the order $|a|$ gets big (towards numbers as big as $2^200$), this approach quickly becomes infeasible.

The assumption that the discrete log cannot be solved trivially in specific groups is the core of cryptographic protocols and algorithms. There are known techniques better than a brute-force search which can solve the discrete log problem either for specific groups or for all groups in general. We shall discuss those methods in a later section, though cryptography is done on well-chosen groups such that even those attacks become infeasible.





/* Addition within the set of integers satisfy certain algebraic properties:

1. There exists an identity. For addition, $0$ is the identity becuase $0 + a = a$.
2. The operation is associative, where $(a + b) + c = a + (b + c)$.
3. Every element has an inverse that is also within the set. For any $a in ZZ$, $-a$ is its inverse because $a + (-a) = 0$ where $0$ is the identity element.
4. Closure. For any $a, b in ZZ$, we have $a + b in ZZ$ as well, therefore the operation will never output a value that leaves the $ZZ$ set.

These four conditions satisfy the requirements for a _group_. We can say that the set of $ZZ$ forms a group under addition. Note that $ZZ$ does _not_ form a group under multiplication, because although it satisfies three of the properties: $1$ is the identity, the operation is associative, and for all $a,b in ZZ, a b in ZZ$ (closure), the inverse property is not satisfied.

For $2$ to have an inverse, there would need to be $a in ZZ$ such that $2  times a = 1$, the identity element. Such an $a$ doesn't exist when $a$ needs to be an integer.

However, we can restrict our set to make it form a group. Consider the numbers ${1, 2, 3, .., n - 1}$ with multiplication modulo $n$, where $n$ is a prime number. We will write this set as $ZZ_n$.

For any $a in ZZ_n$, we have $1 times a = a$, therefore $1$ can be considered as the identity element. The operation is associative in the same way multiplication is associative, with the assumption that multiplying two numbers modulo $n$ is equivalent to multiplying in $ZZ$ then finding the result modulo $n$. Then, as $(a b)c = a(b c)$, we can say $(a b) c = a (b c) " "(mod n)$.

Finding an inverse for an element in $ZZ_n$ requires the use of Fermat's Little Theorem, which states

$
a^(n-1) equiv 1 " "(mod n)
$

when $n$ is prime. Then, we can write $a times a^(n-2) equiv 1 " "(mod n)$. For any $a in ZZ_n$, $a^(n-2)$ is its inverse as the product of $a$ and $a^(n-2)$ gives the identity. It's trivial to show that $ZZ_n$ is closed under multiplication, therefore we can state that the set of non-zero integers modulo $n$ forms a group under multiplication. 

== Introduction
// TODO cite
Internet connections and data go through Internet Service Providers (ISP) which snoop on users' information. [citation needed] An often used method to prevent eavesdropping is through TLS, commonly known as the green padlock next to the address bar or HTTPS, [citation needed] which establishes a secure connection between the user and the website that they are connecting to, such that the ISP only knows which website they have connected to but does not know the content that the user has downloaded or uploaded.

TLS has many different cryptographic techniques to establishing a secure connection. One of which is the Elliptic Curve Diffie-Hellman (ECDH). In this paper, we will examine the mathematical theory underlying the ECDH operation and evaluate its practical application in cybersecurity.

== The Discrete Log Problem in $ZZ_p^times$

As a consequence of Fermat's Little Theorem, we can write:
// todo spacing
$
a^(p-1) equiv 1 " " (mod p)\
a dot a^(p-2) equiv 1 " " (mod p)
$

// TODO cite
For any integer $a$ and prime $p$. We have found $a^(p-2)$ as $a$'s multiplicative inverse, therefore integers modulo $p$ with multiplication forms a group, as the operation is associative, has an identity element, and every element has an inverse. This group is represented with the symbol $ZZ_p^times$.

Given a base $17$ and a value $24$, we can ask the following question:

$
17^n equiv 24 " "(mod 1009)
$

This is called the Discrete Log Problem in $ZZ_p^times$, and in this case $p = 1009$. It is an open cryptographic problem to be able to solve this problem in large $p$ quickly. 

A method named pollard's $rho$ algorithm exists which we can use to find the answer. First, we generate random integers as exponents and write $M$:

$
M_1 = (17)^5 (24)^11\
M_2 = (17)^20 (24)^7\
M_3 = (17)^13 (24)^6\
M_4 = (17)^11 (24)^16\
M_5 = (17)^3 (24)^12
$

// todo probably rename P to x

Then, define $
f(x) = x M_i "if " x equiv i " " (mod 5)
$

This essentially gives a "random walk" of the group. Choose $P_0 = (17^3)(24^14)$, then define $
P_(n+1) = f(P_n)
$

We note that $P_61 = P_99 = 340$. If we kept track of the exponents on $17$ and $24$ in the calculations, we get

$
P_61 = (17^691)(24^704) = (17^1075)(24^1132) = P_99
$

Then

$
17^(-384) = 24^(428)
$

Rewrite $24 = 17^k$

$
17^(-384) = 17^(428k)\
17^(428k + 384) = 1
$

Note that $17$ has order $1008$ in the multiplicative group modulo 1009, therefore we write

$
428 k + 384 = 0 " "(mod 1008)
$

// TODO
(pollards rho, from Washington)

Given $a$ and $b$ are non-zero integers from this group, the discrete log problem asks us to find $k$ such that

$
a^k equiv b " " (mod p)
$


The assumption is that this problem is difficult to compute if the group and the exponent are well-chosen. This is used as the _trapdoor function_ in cryptography, as it is assumed to be easy to compute in one direction and hard to compute in the other. We'll evaluate the extent to which this claim is true for $ZZ_p^times$ in later sections, but we'll start with this assumption. */

= Finite Field Cryptography and Attacks

The term _finite field_ refers to the fact that the set of numbers from 1 to $p - 1$, alongside with zero, form another group under addition. Moreover, multiplication is distributive over addition: $a(b + c) = a b + a c$ mod $p$. A field is a set of elements that forms a group under addition and its non-zero elements forms a group under multiplication, where multiplication distributes over addition. The field of integers modulo $p$ is written as $FF_p$.#footnote[Note that $|FF_p| = p$ due to the inclusion of zero. We use $FF_p^times$ to explicitly refer to the multiplicative subgroup where $|FF_p^times| = p-1$.]

People may wish to communicate privately over public channels such that the information being transmitted is safe from malicious third-party actors. Encryption protocols using cryptography are in place in internet connections to serve this purpose and defend against attacks. For example, as internet traffic usually goes through a _router_, attackers in public networks such as airport or cafe Wi-Fi can simply pretend to be the router and obtain information.#footnote[This is called a _man-in-the-middle_ attack.]

If the information being communicated is encrypted, then attacks like this would not work since the eavesdropper does not know how to decrypt the information. Common efficient encryption algorithms require the people involved to have a *shared secret*, that is, a password for encrypting and decrypting the messages.#footnote[Having a shared secret is called _symmetric key cryptography_. An example of a symmetric key algorithm is the AES] // TODO cite

If the only form of communication between two parties is through a potentially *insecure channel*, as in the case of internet connections, it may be hard to establish such password safely. The Diffie-Hellman Key Exchange is a way to establish a shared secret even if the only channel to communicate in is insecure through the difficulty of the discrete log problem.

== Diffie-Hellman Key Exchange

Given a known base $x$ within a group $G$, one cannot trivially obtain $x^(a b)$ from $x^a$ and $x^b$ if the integers $a$ and $b$ are not known.#footnote[Note that exponentiation here means repeated application of the group operation. In groups where the operation is addition (such as elliptic curves), we will write $a x$ and $b x$ instead.] This is named the Diffie-Hellman problem. If the discrete log problem can be solved trivially, one can simply obtain $b$ from $x^b$ and $x$, then exponentiate $(x^a)^b = x^(a b)$. As such, the difficulty of the Diffie-Hellman problem in a group is partially related to the difficulty of solving DLP in the same group.


With the Diffie-Hellman problem, Alice can establish a shared secret with Bob by having both generate its own secret exponent - either $a$ or $b$. Alice can secretly generate $a$ and send Bob $x^a$, while Bob can secretly generate $b$ and send Alice $x^b$.

Alice can then compute $(x^b)^a$ and Bob can compute $(x^a)^b$. As both of these are are equal to $x^(a b)$, this can be used as the shared secret.

Because only $x$, $x^a$, and $x^b$ are sent across the channel, any third party observer will not be able to compute $x^(a b)$ without solving the Diffie-Hellman problem. As we have assumed that the problem is difficult, this is a secure way for Alice to establish a shared secret with Bob over an insecure channel.

/* 
#align(center, cetz.canvas({
  import cetz.draw: *
  content((0, 0), (2, 1), box(align(center, par[Alice]),
stroke: 1pt, width: 100%, height: 100%, inset: 1em))
  content((7, 0), (9, 1), box(align(center, par[Bob]),
stroke: 1pt, width: 100%, height: 100%, inset: 1em))
  // TODO finish this
}))
*/

== Index Calculus

Diffie-Hellman Key Exchange on Finite Fields normally uses groups $FF_p$ where $2^2048 <= p <= 2^8192$ @friedl_diffie-hellman_2006@velvindron_increase_2017. The size of the prime ensures that solving DLP is inefficient. Below we will describe Index Calculus, which efficiently solves DLP for smaller finite fields.

It is best to illustrate with an example. We'll reuse the one presented earlier:

$
17^n equiv 24" (mod 1009)"
$

To find $n$, we first define a logarithm function $L$. $L(x)$ is defined such that

$
17^L(x) equiv x" (mod 1009)"
$

Note that when we have

$
17^(L(x) + L(y)) equiv 17^(L(x)) times 17^(L(y)) equiv x y equiv 17^(L(x y))" (mod 1009)"
$

So then $
17^(L(x) + L(y) - L(x y)) equiv 1" (mod 1009)"
$

Because the $|17| = 1008$, we have

$
L(x) + L(y) - L(x y) &equiv 0&" (mod 1008)"\
L(x) + L(y) &equiv L(x y)&" (mod 1008)"
$

As such, we have a relation analogous to the laws of logarithm on real numbers. Since every number can be factorized into primes, the idea is the obtain $L(p)$ for small primes $p$, then figuring out $L(24)$ afterwards. We first try to factorize exponents of the base, $17$, looking for ones that can be factorized into relatively small primes:

$
17^15 &equiv 2^2 dot 5 dot 13&" (mod 1009)"\
17^16 &equiv 2^7 dot 3&" (mod 1009)"\
17^24 &equiv 2 dot 11^2&" (mod 1009)"\
17^25 &equiv 2 dot 3 dot 13&" (mod 1009)"\
17^33 &equiv 2^2 dot 3^2 dot 11&" (mod 1009)"\
17^36 &equiv 2^2 dot 7^2&" (mod 1009)"\
$

Applying $L$ to both sides of the equations, we obtain

$
15 &equiv 2 L(2) + L(5) + L(13)&" (mod 1008)"\
16 &equiv 2 L(7) + L(3)&" (mod 1008)"\
24 &equiv L(2) + 2L(11)&" (mod 1008)"\
25 &equiv L(2) + L(3) + L(13)&" (mod 1008)"\
33 &equiv 2 L(2) + 2 L(3) + L(11)&" (mod 1008)"\
36 &equiv 2 L(2) + 2 L(7) &" (mod 1008)"\
$

There are six unknowns $L(2), L(3), L(5), L(7), L(11), L(13)$ and six equations, using linear algebra methods, we can arrive at the solution

$
L(2) = 646, L(3) = 534, L(5) = 886,\
L(7) = 380, L(11) = 697, L(13) = 861
$

Next up, the idea is to find $17^x dot 24$ and find one that can factorize over primes not greater than 13. Indeed, we have $17^2 dot 24 equiv 2 dot 3^2 dot 7^2" (mod 1009)"$, so then we have

$
2 + L(24) equiv L(2) + 2L(2) + 2L(7)" (mod 1008)"\
L(24) = 456 = n
$

Therefore, we indeed arrive at the answer $n = 456$. As seen above, this method relies on the property that prime factorizations always exist, which may not apply to ellpitic curves.

General Number Field Sieve#footnote[Name is based on how the factoring step is also done in parallel on a General Number Field. Describing the details of the algorithm requires way more background material than normal index calculus, therefore out of scope of this essay.] is a more sophisticated form of index calculus and in general more efficient than the normal index calculus for large primes @nguyen_index_2005. The number of operations expected for the algorithm can be written as @lenstra_l-notation_2005:

$
exp((64\/9)^(1\/3)(ln p)^(1\/3)(ln ln p)^(2\/3))
$

where $p$ is the prime that defines the finite field in $FF_p$. For a field with $p = 2^2048$, it will take about $1.5 dot 10^35 approx 2^117$ operations. In later sections, we will take a look at Diffie-Hellman done on elliptic curves and how the number of operations needed to solve the discrete log problem on elliptic curves compares with Diffie-Hellman on finite fields.

= Elliptic Curve Cryptography

Let an elliptic curve be denoted by the equation $y^2 = x^3 + A x + B$ where $A$ and $B$ are constants. Note that the curve is symmetric about the $x$-axis, since if $(x,y)$ is a point on the curve, $(x,-y)$ is also on the curve.

Let $P_1 = (x_1,y_1)$ and $P_2 = (x_2,y_2)$ be distinct points on the curve, where $x_1 !=x_2$. We can find a new point on the curve by defining a line that goes across the two points, with slope

$
m = (y_2 - y_1)/(x_2 - x_1)
$

And line equation $
y = m(x-x_1) + y_1
$

We substitute this into the equation of the curve:

$
(m(x-x_1) + y_1)^2 = x^3 + A x + B
$

Expanding and rearranging gives:

$
x^3 - m^2 x^2 + (2m^2 x_1 - 2y_1m + A)x + 2y_1 m x_1 - m^2 x_1^2 - y_1 = 0
$

With Vieta's formulas, the sum of roots for the cubic is $m^2$. We already know two roots of this polynomial as $P_1$ and $P_2$ are common points on the curve and the line, so we can find the $x$ coordinate of the third point:

$
x_3 = m^2 - x_1 - x_2
$

In the group law, the $y$ coordinate of the resulting point is flipped: (TODO: explain why)

$
y_3 = -(m(x_3 - x_1) + y_1) =m(x_1-x_3) -y_1
$

Therefore, we have arrived at $P_3 = (x_3, y_3)$, a third point distinct from $P_1$ and $P_2$.

If only one point $P_1 = (x_1, y_1)$ is known, we can use implicit differentiation to find the tangent line:

$
y^2 = x^3 + A x + B\
2 y (dif y)/(dif x) = 3x^2 + A\
m = (dif y)/(dif x) = (3x^2 + A)/(2y) = (3x_1^2 + A)/(2 y_1)
$

With the same line equation $y = m(x - x_1) + y_1$, with the same expanded formula:

$
x^3 - m^2 x^2 + ... = 0
$

But this time, $x_1$ is a repeated root, as a tangent line either touches no other points at all (the case when $y = 0$) or touch one other point.

Therefore, we can find the third point with

$
x_3 = m^2 - 2 x_1
$

And $
y_3 = -(m(x_3 - x_1) + y_1) = m(x_1 - x_3) - y_1
$

Therefore, we can begin to define a group law for points on elliptic curves.

Let $C: y^2 = x^3 + A x + B$ be the elliptic curve with the set of points that satisfy the given equation. We now show that $C union {infinity}$ forms a group.

Let $P_1 = (x_1, y_1)$ and $P_2 = (x_2, y_2)$ be two points that are on the curve. Define $P_3 = P_1 + P_2$ to be as follows:

- If $P_1 = P_2 = (x_1, y_1)$, let $

P_3 = (m^2 - 2x_1, m(x_1-x_3)-y_1), "where " m = (3x_1^2 + A)/(2y_1)

$
- If $x_1 = x_2$ but $y_1 != y_2$ (N.B. the only case where this happens is $y_1 = -y_2$): let $P_3 = infinity$.
- Otherwise, let $
P_3 = (m^2 - x_1 - x_2, m(x_1-x_3)-y_1), "where " m = (y_2-y_1)/(x_2-x_1)
$

Additionally, define $P_1 + infinity = infinity + P_1 = P_1$, as well as $infinity + infinity = infinity$.

Perhaps the most surprising result of defining this operation is that the operation is associative, that is, $(P_1 + P_2) + P_3 = P_1 + (P_2 + P_3)$ for any three points $P_1, P_2, P_3$ that belong to the set $C union { infinity }$. Proving this algebraicly becomes very tedious, but there is a geometric argument using cubics and Bézout's theorem for the case where the points are distinct and none of them have the same $x$ value.

== Proof of Associativity

Bézout's theorem states that in general two plane curves given in the equations $a(x, y) = 0$ and $b(x, y) = 0$ with degrees $d_a$ and $d_b$ will have $d_a d_b$ intersections. 

Formally, the group of elliptic curves can be defined in projective space where the point at infinity can be treated like any other point. For ease of presentation, the point at infinity will be denote as $O$.

#image("Screenshot_20240626_152533.png")

Note that the intersections between the blue lines and the curve are $(P+Q)*R$, $P$, $Q$, $R$, $Q*R$, $Q+R$, $P*R$, $P+Q$, and $O$.

The intersections between the black lines and the elliptic curve are $P * (Q + R)$, $P$, $Q$, $R$, $Q*R$, $Q+R$, $P*R$, $P+Q$, and $O$.

As three lines form a cubic, and the two groups of three lines both intersect the same eight out of the nine points with the elliptic curve, it can be shown that the ninth point is the same for both cubics that intersect with the elliptic curve, thus proving that $(P+Q)*R = P * (Q + R)$. // TODO elaborate this reasoning

== Group of elliptic curve points

Therefore, $C union {infinity}$ forms a group since:

1. The operation $+$ is well-defined for any points $P_a + P_b$ where $P_a, P_b in C union {infinity}$ as above.
2. $infinity$ is the identity element, where $P_a + infinity = P_a$ for all $P_a in C union {infinity}$.
3. Every element has an inverse: let $P_a = (x, y)$, its inverse is $-P_a = (x, -y)$. We know that $-P_a in C$ since the curve is given as $y^2 = x^3 + A x + B$ and swapping $y$ with $-y$ will still hold.
4. The operation is associative.

Since elliptic curve points form a group, cryptographic techniques such as diffie-hellman key exchange which relies on group operations can also be applied to elliptic curves.

== Elliptic curve diffie-hellman

One important difference between elliptic curve operations and modular multiplicative group operations is in notation. In elliptic curve, the operation is commonly represented as addition of two points. Therefore $A + B$ is the normal operation on two points $A$ and $B$ while $k A$ is the operation repeated (e.g. $2A = A + A$). In the multiplicative group modulo $p$, the correspondence goes to $A B$ and $A^k$. Thus, in previous sections about the multiplicative groups, an operation such as $A^k$ will now be written as $k A$ in the context of elliptic curves.

With that note, diffie-hellman in elliptic curves follows the exact same procedure: two parties agree on a curve group to use, then decide on a base point $G$. Alice generates a secret integer $a$ and sends Bob $a G$. Bob generates a secret integer $b$ and sends Alice $b G$. They can now both calculate $a b G$, which cannot be known by third parties unless they can solve the discrete log problem in elliptic curves.

// TODO: Example

== Finding the Discrete Log with Pollard's $rho$ algorithm

Pollard's $rho$ algorithm is a general algorithm for solving the discrete log problem for any abelian group. It is less efficient than the general number field sieve on discrete log in finite fields, taking $O(sqrt(N))$ time on average with $N$ being the order of the group. // TODO revisit

We first take an example adapted from page 164 of Silverman and Tate's book: $y^2 = x^3 + 6692x + 9667$, in $F_10037$, with $P = (3354, 7358)$, $Q = (5403, 5437)$. Find $k$ such that $k P = Q$.#footnote[Originally a Montgomery equation, used substitution to turn it into the short Weierstrass form for consistency.]

Generate 10 random points on the curve based on multiples of $P$ and $Q$:

// TODO make these occupy less space.
$
M_0 = 42P + 37Q #h(25pt) M_1 = 21P + 12Q #h(25pt) M_2 = 25P + 20Q\
M_3 = 39P + 15Q #h(25pt) M_4 = 23P + 29Q #h(25pt) M_5 = 45P + 25Q\
M_6 = 14P + 37Q #h(25pt) M_7 = 30P + 12Q #h(25pt) M_8 = 45P + 49Q #h(25pt) M_9 = 40P + 45Q\
$

Then pick, in the same way, a random initial point:

$
A_0 = 15P + 36Q = (7895, 3157)
$

Then, choose an $M_i$ point to add to based on the ones digit of the $x$ coordinate of the point. As $A_0$ has $x = 7895$, $A_1 = A_0 + M_5 = (7895, 3157) + (5361, 3335) = (6201, 273)$.

Formally, define $
A_(n+1) = A_n + M_i" where " i equiv x_n" (mod 10)"
$

for $A_n = (x_n,y_n)$.  The choice of random $M_i$ points creates a kind of "random walk" of the points in the elliptic curve. As we keep calculating, we get:

$
A_0 &= (7895, 3157), A_1 &=& (6201, 273), ...,\
A_95 &= (170, 7172), A_96 &=& (7004, 514), ...,\
A_100 &= (170, 7172), A_101 &=& (7004, 514) 
$

We reach a cycle with $A_95 = A_100$. Since we know the multiples of $P$ and $Q$ for all of the $M_i$ points and thus all $A_n$ points, keeping track of them gives us $A_95 = 3126P + 2682Q$, we also have $A_100 = 3298P + 2817Q$. With $3126P + 2682Q = 3298P + 2817Q$, we have:

$
infinity = 172P + 135Q = (172 + 135n)P\
172 + 135n equiv 0" (mod 10151)"
n equiv 1277" (mod 10151)"
$

With verification, we indeed have $1277P = Q$.

= Evaluation

Pollard's $rho$ algorithm on elliptic curve groups works on average with $sqrt(pi/4 N)$ elliptic curve additions with $N$ being the order for the base point $P$ @bernstein_correct_2011. On the other hand, the general number field sieve takes about $exp((64\/9)^(1\/3)(ln p)^(1\/3)(ln ln p)^(2\/3))$ in a prime field with order $p$. Assigning real numbers to these expressions, we should take a look at the current industry standards.

== Diffie-Hellman in TLS 1.3

The Transport Layer Security (TLS) protocol is the protocol used in virtually all internet connections that are protected through cryptography @heinrich_transport_2011. One important part of this protocol is Diffie-Hellman Key Exchange. As of writing, the latest version of TLS is 1.3. We shall now examine the Diffie-Hellman methods it supports.

=== Finite Field Diffie-Hellman

The smallest finite field used by TLS for Diffie-Hellman is named ffdhe2048 @rescorla_transport_2018, with the prime modulus defined as $
p = 2^2048 - 2^1984 + (floor(2^1918 dot e) + 560316) dot 2^64 - 1
$

With the group size being $(p - 1) \/ 2$. If we computed the number of operations needed for the general number field sieve to run, we get approximately $2^117$ operations or that the field provides 117 bits of security. The original definition /* TODO from where? */ indeed has taken a conservative estimate that this provides 103 bits of security @gillmor_negotiated_2016.

As this field uses a prime 2048 bits of size, each group element requires 2048 bits of storage or 2KiB of storage.

=== Elliptic Curve Diffie-Hellman

The smallest elliptic curve supported by TLS appears to be curve25519, using the prime $2^255 - 19$ as the field the elliptic curve is over, and the curve $y^2 = x^3 + 486662 x^2 + x$. The order of the group is $2^252 + 27742317777372353535851937790883648493$. As the fastest method to break the discrete logarithm takes $sqrt(pi/4 N)$ operations, this specific curve requires approximately $2^126$ operations to break, or providing 126 bits of security.

As elliptic curve points have coordinates under the prime field $2^255 - 19$, each coordinate requires 255 bits of storage, making the point requiring 510 bits of storage. Therefore, each group element requires approximately 0.5KiB of storage.

== Performance of group operations

Assume that multiplying two $256$-bit integers has cost $bold(C)$. Multiplication of two $2048$-bit integers thus will cost $64bold(C)$ as each $2048$-bit integer has $8$ $256$-bit digits and each digit from the first operand needs to multiply with the next operand.

The story in elliptic curves is much more complicated. Curve25519 follows the form $B y^2 = x^3 + A x^2 + x$ called a Montgomery curve. All curves of this form can be transformed into the short Weierstrass form but not the other way around. Detailed in @costello_montgomery_2018, the diffie-hellman key exchange protocol could be designed so that only the $x$-coordinate of each point in the process is needed, which simplifies the process by removing the need to compute $y$ coordinates. Under the arithmetic of only the $x$ coordinates of curve points, adding two curve points costs $3M + 2S + 3a + 3s$, where $M, S, a, s$ are costs for multiplying two numbers, squaring a number, adding two numbers, subtracting two numbers in the field the curve is defined on respectively. Assuming that the cost for addition and subtraction is negligible compared to multiplication, and assuming that squaring has approximately the same cost as multiplying two numbers,#footnote[In reality, squaring has slightly less costs than multiplying as the former can be optimized a bit more for efficiency.] the cost for adding two curve points is approximately $5M$. Note that the field is defined over $2^255 - 19$, so the cost of a multiplication $M$ (for two $255$-bit integers) can be considered as less than the cost of multiplying two $256$-bit integers. So we have $M < bold(C)$.

Note how adding two curve points only costs $5M$, while multiplying in finite fields costs $64bold(C)$. (approximately 13x difference) As performing the group operation is the primary backbone behind Diffie-Hellman key exchange, this performance difference can have huge implications.

/* Doubling a curve point costs $2M + 2S + 1c + 3a + 1s$ where $c$ is the cost of multiplying by $(A + 2) / 4 = 121666$ for curve25519. For the same reason we assume that this costs approximately $4M$. */

== Comparison

The specific methods we have chosen to evaluate provide a general insight into the efficiencies of different methods of diffie-hellman key exchange. In general, elliptic curves take much less space to store (providing similar bits of security will using approximately four times less storage for each group element)

#bibliography("shortlist.bib")